<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnrc_arbiter &mdash; Limber FPGA Platform 0.1 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="prev" title="gnrc_spram" href="gnrc_spram.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #116699" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Limber FPGA Platform
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Limber Generic</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../common_cells/index.html">Common cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="../general_old/index.html">General old</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Generic</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="index.html#include">Include</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#codec">CODEC</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#ram">RAM</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html#handshake">Handshake</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">gnrc_arbiter</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #116699" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Limber FPGA Platform</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Limber Generic</a></li>
          <li class="breadcrumb-item"><a href="index.html">Generic</a></li>
      <li class="breadcrumb-item active">gnrc_arbiter</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/generic/generic/gnrc_arbiter.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="gnrc-arbiter">
<h1>gnrc_arbiter<a class="headerlink" href="#gnrc-arbiter" title="此标题的永久链接"></a></h1>
<div class="line-block">
<div class="line">Round-Robin and Priority arbitor.</div>
<div class="line">derived from pulp/common_cell/rr_arb_tree</div>
<div class="line">modified by qyley(<a class="reference external" href="mailto:qyley&#37;&#52;&#48;foxmail&#46;com">qyley<span>&#64;</span>foxmail<span>&#46;</span>com</a>)</div>
<div class="line"><br /></div>
<div class="line">update log:</div>
<div class="line">- add <cite>lock_i</cite> &amp; <cite>lock_o</cite>, granted requester can assert a <cite>lock_i</cite> signal</div>
<div class="line-block">
<div class="line">to prevents the arbiter from changing the arbitration decision in next clock.</div>
</div>
<div class="line">- remove <cite>LockIn</cite> Parameter, since it can be replaced by <cite>lock_i</cite></div>
<div class="line">- Use an intrinsic tree fabric to replace the <cite>lzc</cite> module in original <cite>rr_arb_tree</cite>,</div>
<div class="line-block">
<div class="line">making a notable reduction of timing path and area.</div>
</div>
<div class="line">- add a new <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> updating method, see the parameter <cite>EXT_RR</cite> and <cite>DEPTH</cite>.</div>
</div>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="此标题的永久链接"></a></h2>
<span id="ext-rr"></span><table class="docutils align-default" id="depth">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>parameter</p></th>
<th class="head"><p>datatype</p></th>
<th class="head"><p>range</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>N</p></td>
<td><p>int unsigned</p></td>
<td><p>&gt;=1</p></td>
<td><p>Number of inputs to be arbitrated.</p></td>
</tr>
<tr class="row-odd"><td><p>DW</p></td>
<td><p>int unsigned</p></td>
<td><p>&gt;=1</p></td>
<td><p>Data width of the payload in bits. Lose efficacy if <code class="docutils literal notranslate"><span class="pre">DTYPE</span></code> is overwritten.</p></td>
</tr>
<tr class="row-even"><td><p>EXT_RR</p></td>
<td><p>bit</p></td>
<td><p>{0,1}</p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">EXT_RR</span></code> option allows to override the internal round robin counter via the <cite>rr_i</cite> signal. <code class="docutils literal notranslate"><span class="pre">rr_i</span></code> must be a big-endian thermometer code signal, such as ‘1111_1000’ which means the priority of idx is ‘3,4,5,6,7,0,1,2’. This can be useful in case multiple arbiters need to have rotating priorities that are operating in lock-step. If static priority arbitration is needed, just connect <code class="docutils literal notranslate"><span class="pre">rr_i</span></code> to ‘0. Set to 1’b1 to enable.</p></td>
</tr>
<tr class="row-odd"><td><p>LEAKY</p></td>
<td><p>bit</p></td>
<td><p>{0,1}</p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">LEAKY</span></code> is set, the <code class="docutils literal notranslate"><span class="pre">req_o</span></code> will leak out whenever any <code class="docutils literal notranslate"><span class="pre">req_i</span></code> is valid, and the <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> will leak out whenever <code class="docutils literal notranslate"><span class="pre">gnt_i</span></code> is valid. Enabling <code class="docutils literal notranslate"><span class="pre">LEAKY</span></code> make the request no longer depends on grant, leads to a reduction of arbiter delay and area. Set to 1’b1 to enable.</p></td>
</tr>
<tr class="row-even"><td><p>DEPTH</p></td>
<td><p>int</p></td>
<td><p>{0,1,2}</p></td>
<td><p>There are three basic methods for updating the round-robin pointer:</p>
<ol class="arabic simple">
<li><p>After a grant, increment the pointer. This method don’t cares which request is, so depth is 0.</p></li>
<li><p>After a grant, move the pointer to the requester after the one which just received the grant. This method only cares which request is granted, so depth is 1.</p></li>
<li><p>After a grant, move the pointer to the first Active requester after the one which just received the grant. This method cares which request is granted and the next valid request, so depth is 2.</p></li>
</ol>
<p>Change <cite>DEPTH</cite> to set the updating method.</p>
</td>
</tr>
<tr class="row-odd"><td><p>DTYPE</p></td>
<td><p>type</p></td>
<td><p>logic [DW-1:0]</p></td>
<td><p>Data type of the payload, can be overwritten with custom type. Only use of <cite>DW</cite>.</p></td>
</tr>
<tr class="row-even"><td><p>AW</p></td>
<td><p>int unsigned</p></td>
<td><p>$clog2(N)+(N==1)</p></td>
<td><p>Width of the arbitration priority signal and the arbitrated index. (auto-gen, do <strong>NOT</strong> change)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="ios">
<h2>IOs<a class="headerlink" href="#ios" title="此标题的永久链接"></a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 13%" />
<col style="width: 25%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>signal</p></th>
<th class="head"><p>I/O</p></th>
<th class="head"><p>width</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>clk_i</p></td>
<td><p>input</p></td>
<td><p>logic</p></td>
<td><p>Clock, positive edge triggered.</p></td>
</tr>
<tr class="row-odd"><td><p>rst_ni</p></td>
<td><p>input</p></td>
<td><p>logic</p></td>
<td><p>Asynchronous reset, active low.</p></td>
</tr>
<tr class="row-even"><td><p>flush_i</p></td>
<td><p>input</p></td>
<td><p>logic</p></td>
<td><p>Clears the arbiter state. Only used if <code class="docutils literal notranslate"><span class="pre">EXT_RR</span></code> is <cite>1’b0</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p>rr_i</p></td>
<td><p>input</p></td>
<td><p>logic [N-1:0]</p></td>
<td><p>External round-robin priority. Only used if <code class="docutils literal notranslate"><span class="pre">EXT_RR</span></code> is <cite>1’b1.</cite></p></td>
</tr>
<tr class="row-even"><td><p>req_i</p></td>
<td><p>input</p></td>
<td><p>logic [N-1:0]</p></td>
<td><p>Input requests arbitration.</p></td>
</tr>
<tr class="row-odd"><td><p>lock_i</p></td>
<td><p>input</p></td>
<td><p>logic [N-1:0]</p></td>
<td><p>Input request locks.</p></td>
</tr>
<tr class="row-even"><td><p>gnt_o</p></td>
<td><p>output</p></td>
<td><p>logic [N-1:0]</p></td>
<td><p>Input request is granted.</p></td>
</tr>
<tr class="row-odd"><td><p>data_i</p></td>
<td><p>input</p></td>
<td><p>DTYPE [N-1:0]</p></td>
<td><p>Input data for arbitration.</p></td>
</tr>
<tr class="row-even"><td><p>req_o</p></td>
<td><p>output</p></td>
<td><p>logic</p></td>
<td><p>Output request is valid.</p></td>
</tr>
<tr class="row-odd"><td><p>lock_o</p></td>
<td><p>output</p></td>
<td><p>logic</p></td>
<td><p>Output request lock.</p></td>
</tr>
<tr class="row-even"><td><p>data_o</p></td>
<td><p>output</p></td>
<td><p>DTYPE</p></td>
<td><p>Output data.</p></td>
</tr>
<tr class="row-odd"><td><p>idx_o</p></td>
<td><p>output</p></td>
<td><p>logic [AW-1:0]</p></td>
<td><p>Index from which input the data came from.</p></td>
</tr>
<tr class="row-even"><td><p>gnt_i</p></td>
<td><p>input</p></td>
<td><p>logic</p></td>
<td><p>Output request is granted.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="derived-from-rr-arb-tree">
<h2>Derived from ‘rr_arb_tree’<a class="headerlink" href="#derived-from-rr-arb-tree" title="此标题的永久链接"></a></h2>
<p>此代码来自于对 <cite>rr_arb_tree</cite> 的修改，强烈建议先查看 <a class="reference external" href="https://github.com/pulp-platform/common_cells/blob/master/src/rr_arb_tree.sv">源码</a>
或其他介绍该源码的 <a class="reference external" href="https://zhuanlan.zhihu.com/p/593368451">相关文章</a> 来初步了解该设计的基础原理</p>
</section>
<section id="arbiter">
<h2>Arbiter<a class="headerlink" href="#arbiter" title="此标题的永久链接"></a></h2>
<p>仲裁器Arbiter是数字设计中非常常见的模块，应用也非常广泛。定义就是当有两个或两个以上的模块需要占用同一个资源的时候，我们需要由仲裁器arbiter来决定哪一个模块来占有这个资源。一般来说，提出占有资源的模块要产生一个请求(request)，所有的请求送给仲裁器之后，仲裁器要返回一个许可(grant)。</p>
<p>仲裁器很重要的一点是只能让一个模块得到许可，因为这个资源某一时刻只能由一个模块占用。在数字电路中，总线仲裁是一个常见的例子，比如多个master要占用总线来去写数据，那么需要仲裁器来许可哪个master来占用总线。</p>
</section>
<section id="lock-i">
<h2>lock_i<a class="headerlink" href="#lock-i" title="此标题的永久链接"></a></h2>
<p>带有 <code class="docutils literal notranslate"><span class="pre">lock_i</span></code> 输入的仲裁器可以使被许可的请求者（granted requester）持续占用仲裁资源，当需要持续多个周期发送数据时，为避免发送过程中仲裁器切换许可， <code class="docutils literal notranslate"><span class="pre">lock_i</span></code> 的功能是必须的。</p>
<p>gnrc_arbiter 为 rr_arb_tree 拓展了 <code class="docutils literal notranslate"><span class="pre">lock_i</span></code> 的功能，这使得该仲裁器可以用在支持 packet mode 的 AXI4 Stream 等协议中。</p>
<img alt="../../_images/arbiter_lock.svg" src="../../_images/arbiter_lock.svg" /></section>
<section id="fix-priority">
<h2>Fix priority<a class="headerlink" href="#fix-priority" title="此标题的永久链接"></a></h2>
<p>固定优先级（Fix priority）顾名思义就是按照固定的优先顺序对同时发起请求的 requester 进行许可，一般 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 的低位优先级最高，也可以设置 <cite>EXT_RR</cite> 通过外部输入 <code class="docutils literal notranslate"><span class="pre">rr_i</span></code> 来自定义优先级，详见参数 <a class="reference internal" href="#ext-rr">EXT_RR</a> 的说明。</p>
<p>Fix priority 在竞争激烈的情况下容易导致优先级低的 requester 一直得不到许可，出现“饿死”的情况。</p>
</section>
<section id="round-robin">
<h2>Round Robin<a class="headerlink" href="#round-robin" title="此标题的永久链接"></a></h2>
<p>轮询（Round Robin）仲裁器可以根据许可情况自动对各个 requester 的优先级进行旋转（rotate），使得每个 requester 都有机会成为最高优先级，增加了公平性。</p>
<p>Round Robin 内置一个寄存器 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 来保存优先级最高（或最低）的 requester 的编码， 通过旋转 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 来更新每个 requester 的优先级。 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 主要有 3 种更新模式：</p>
<ol class="arabic simple">
<li><p>每许可一次，就将 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 指向下一个 <cite>requester</cite>。这种模式下 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 就像一个不断 +1 的计数器，许可的顺序比较随机，有的情况下还是会出现一个 requester 持续占用好几个周期，其他 requester 只能等待的情况，公平性较差， rr_arb_tree 将之称为 unfair arbiter。</p></li>
</ol>
<img alt="../../_images/arbiter_depth0.svg" src="../../_images/arbiter_depth0.svg" /><ol class="arabic simple" start="2">
<li><p>每许可一次，就将 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 指向当前许可 <cite>requester</cite> 的下一个 <cite>requester</cite>。这种模式下可以保证被许可过的 <cite>requester</cite> 在下一轮仲裁时的优先级最低，可以避免持续占用，但无法在时间顺序上保证公平。下图中的 req7 早于 req6， 但后到的 req6 却先获取了许可</p></li>
</ol>
<img alt="../../_images/arbiter_depth1.svg" src="../../_images/arbiter_depth1.svg" /><ol class="arabic simple" start="3">
<li><p>每许可一次，就将 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 指向当前许可 <cite>requester</cite> 的下一个 <strong>有效的</strong> <cite>requester</cite>。 这种模式下可以保证下一个 <strong>有效的</strong> <cite>requester</cite> 一定会在下一个周期被许可，也许是一种更加公平的做法。</p></li>
</ol>
<img alt="../../_images/arbiter_depth2.svg" src="../../_images/arbiter_depth2.svg" /><p>实际上三种更新策略没有绝对的优劣之分，更新模式越复杂电路也越复杂，设计者们可以在例化该模块时通过配置 <a class="reference internal" href="#depth">DEPTH</a> 参数自行选择3种更新模式的其中1种实现。</p>
</section>
<section id="coding-of-rr-q">
<h2>Coding of “rr_q”<a class="headerlink" href="#coding-of-rr-q" title="此标题的永久链接"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 寄存器用于保存对当前优先级最高（或最低）的 requester 进行的编码， <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 的编码方式主要有 3 种：</p>
<ol class="arabic simple">
<li><p>二进制编码（Binary Code），也就是直接把最高（或最低）优先级 requester 的序号（idx）保存下来，这种编码只需要 ceil(log(N)) 的位宽，可以节省寄存器数量，在 rr_arb_tree 中就是采用了这种编码。但是这种编码在进行许可（ <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> ）时还是需要译码为向量形式，增加了产生许可的电路面积。 rr_arb_tree 取巧地使用二进制编码直接产生 grant ，避免对二进制进行译码，虽然减少了电路面积，但没有完全实现按优先级顺序来给予许可， 其中可能出现的问题会在 <a class="reference internal" href="#select-req-o-out-of-many-req-i">Select “req_o” out of many “req_i”</a> 小节讨论。 其次 rr_arb_tree 还使用 2 个 leading zero counter 电路来产生下一个有效的 <cite>requester</cite> 的 idx，也是带来了额外的开销。</p></li>
<li><p>独热码（One-hot code），独热码是一种向量形式的编码，需要 N 的位宽，只在最高（或最低）优先级的 requester 对应比特为 1 ，其余比特为 0，独热码就是二进制编码的译码后的形式。由于仲裁器的许可（ <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> ）信号本身就是独热码，因此使用独热码作为 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 是很方便的，并且独热码只需要进行移位即可实现优先级的旋转。但独热码还是无法直接用于产生仲裁许可。</p></li>
<li><p>温度计码（Thermometer Code），温度计码通过看编码中“有多少个连续的1”来表示数字（就像人们数数时，竖起手指数一样）。温度计码的这种特性可以被仲裁器作为掩码（mask）来使用。例如当 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 中的温度计码为“1111_1000”时，通过与输入 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 按位相与，就能将 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 分为两组，一组是温度计码中 “1” 所对应的比特，另一组是 “0” 所对应的比特，其“1”组对应的请求优先级比“0”组要高。通过改变温度计码的1的数量就能实现优先级的旋转，这也能通过移位来实现。相较于独热码，温度计码能直接参与树形结构中生成sel信号的逻辑运算，也能很方便地将 <cite>grant_o</cite> 信号转化为温度计码的形式（实际上为了缩短关键路径，在 gnrc_arbiter 中，温度计编码的 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 是使用了与生成 <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> 信号类似的另外一块电路来产生的）。 因此 gnrc_arbiter 将 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 的编码方式改为了温度计码，避免了 rr_arb_tree 中对二进制码的额外译码开销以及 leading zero counter 电路的开销。</p></li>
</ol>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Binary</p></th>
<th class="head"><p>One-hot</p></th>
<th class="head"><p>Thermometer(Big-endian)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>000</p></td>
<td><p>0000_0001</p></td>
<td><p>0000_0000/1111_1111(overflow)</p></td>
</tr>
<tr class="row-odd"><td><p>001</p></td>
<td><p>0000_0010</p></td>
<td><p>1000_0000</p></td>
</tr>
<tr class="row-even"><td><p>010</p></td>
<td><p>0000_0100</p></td>
<td><p>1100_0000</p></td>
</tr>
<tr class="row-odd"><td><p>011</p></td>
<td><p>0000_1000</p></td>
<td><p>1110_0000</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>0001_0000</p></td>
<td><p>1111_0000</p></td>
</tr>
<tr class="row-odd"><td><p>101</p></td>
<td><p>0010_0000</p></td>
<td><p>1111_1000</p></td>
</tr>
<tr class="row-even"><td><p>110</p></td>
<td><p>0100_0000</p></td>
<td><p>1111_1100</p></td>
</tr>
<tr class="row-odd"><td><p>111</p></td>
<td><p>1000_0000</p></td>
<td><p>1111_1110</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tree-style-structure">
<h2>Tree-style structure<a class="headerlink" href="#tree-style-structure" title="此标题的永久链接"></a></h2>
<p>使用树形结构可以缩短仲裁选择电路的关键路径长度，参考FFT（Fast Fourier Transformation)和IFFT（Inverse FFT）中的蝶形计算网络，树形网络是其中的一个子集，存在以下两种构造方式，图中所有的正方形节点可视为 2选1 MUX 或 DeMUX。</p>
<img alt="../../_images/arbiter_tree_style.svg" src="../../_images/arbiter_tree_style.svg" /><p>上图左侧为一棵 odd-even tree（自己起的名字），因为它按照节点的奇偶性进行分组， odd-even tree 可以保证叶子节点的顺序在传播过程中不被破坏。</p>
<p>上图右侧为一棵 left-right tree（也是自己起的名字），因为它把每层的节点进行左右分组，左侧节点对应一个右侧节点接入下一层。 虽然 left-right tree 不能保证叶子节点的顺序，但这一特性反而可以用在需要对数据顺序进行交换的场合。</p>
<p>由于仲裁器需要维持 requester 本身的顺序，因此使用 odd-even tree 来进行产生所需要的信号是比较方便的。</p>
</section>
<section id="select-req-o-out-of-many-req-i">
<h2>Select “req_o” out of many “req_i”<a class="headerlink" href="#select-req-o-out-of-many-req-i" title="此标题的永久链接"></a></h2>
<p>从一颗 odd-even tree 的叶子节点出发，将 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 依次输入各个叶子节点，经过多层 MUX 选择，最终在树根产生被许可的 <code class="docutils literal notranslate"><span class="pre">req_o</span></code> 输出。</p>
<p>原始的 rr_arb_tree 的选择判断条件是有缺陷的，无法保证叶子节点中按 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 从低位（左）到高位（右）的优先顺序选取。下面是 rr_arb_tree 中每个节点产生选择信号的逻辑，因为 rr_arb_tree 中的 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 是二进制编码的，为了避免译码开销，rr_arb_tree 直接用二进制的比特作为条件，只有当 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 所对应的最高优先级 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 信号为 1 时，该电路才能正常工作，否则选择出的 <code class="docutils literal notranslate"><span class="pre">req_o</span></code> 顺序是混乱的。</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Idx1 is odd node idx, Idx1 + 1 is even node idx</span>
<span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="p">;</span>

<span class="c1">// sel = 1 select even node, otherwise select odd node</span>
<span class="k">assign</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="o">~</span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="o">+</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">rr_q</span><span class="p">[</span><span class="n">NumLevels</span><span class="o">-</span><span class="mh">1</span><span class="o">-</span><span class="n">level</span><span class="p">];</span>
</pre></div>
</div>
<p>如下图所示，若 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 存储的最高优先级 idx 为 3 ，那么在 <code class="docutils literal notranslate"><span class="pre">req_i[4]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">req_i[5]</span></code> 同时拉高的情况下，正确的输出应该是将 <code class="docutils literal notranslate"><span class="pre">req_i[4]</span></code> 选择出来，但 rr_arb_tree 的电路则会选择 <code class="docutils literal notranslate"><span class="pre">req_i[5]</span></code> 。这是因为 rr_arb_tree 没有对 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 的二进制编码进行译码，判断条件中缺少了最高优先级以外的顺序信息。</p>
<img alt="../../_images/arbiter_gen_idx.svg" src="../../_images/arbiter_gen_idx.svg" /><p>gnrc_arbiter 为了实现完全的轮询仲裁，使用温度计码代替二进制码用于产生选择信号， <a class="reference internal" href="#coding-of-rr-q">Coding of “rr_q”</a> 中提到，温度计码可以作为掩码使用，将输入的 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 向量分为两组，掩码为”1”的比特位优先级高于掩码为”0”的比特位。若掩码相同，则按照从低位（左）到高位（右）的优先顺序选取。整理出来的选择信号真值表如下。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>req[odd]</p></th>
<th class="head"><p>req[even]</p></th>
<th class="head"><p>mask[odd] (rr_q)</p></th>
<th class="head"><p>mask[even] (rr_q)</p></th>
<th class="head"><p>sel</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>x</p></td>
<td><p>x</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>gnrc_arbiter 使用的产生选择信号的代码如下。</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Idx1 is odd node idx, Idx2 is even node idx</span>
<span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="p">;</span>
<span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="o">+</span><span class="mh">1</span><span class="p">;</span>

<span class="c1">// sel = 1 select even node, otherwise select odd node</span>
<span class="k">assign</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w">  </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span>
<span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w">  </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span>
<span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="o">~</span><span class="n">req_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">];</span>
</pre></div>
</div>
<p>在相同的情况下，使用温度计码作为掩码，<code class="docutils literal notranslate"><span class="pre">req_i[4]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">req_i[5]</span></code> 的掩码都为 1，MUX节点会优先选择低位的 req 请求，最终按照正确的轮询顺序输出仲裁结果。</p>
<img alt="../../_images/arbiter_gen_therm.svg" src="../../_images/arbiter_gen_therm.svg" /></section>
<section id="generate-next-rr-q">
<h2>Generate next “rr_q”<a class="headerlink" href="#generate-next-rr-q" title="此标题的永久链接"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 是 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 寄存器的输入，用于产生下一个时钟周期的”rr_q”。</p>
<p>在 rr_arb_tree 中， 输入 <code class="docutils literal notranslate"><span class="pre">req_i</span></code> 被根据 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 编码为两组 <code class="docutils literal notranslate"><span class="pre">upper_mask</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lower_mask</span></code> 信号（这一点与温度计码的作用类似），然后分别送入一个 leading zero counter ，最后在两个 lzc 的输出中选择一个作为 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 。</p>
<p>由于 rr_arb_tree 使用的二进制编码，因此产生 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 的过程较为复杂，如果直接将温度计码保存在 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> ，就可以像 <a class="reference internal" href="#select-req-o-out-of-many-req-i">Select “req_o” out of many “req_i”</a> 中描述的类似电路，只通过一个树形结构来生成 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 。</p>
<p>使用树形结构生成温度计码，需要记录下从叶子到根节点的选择路径（也就是每个节点的sel信号），然后倒推过来将被选中的叶子节点所对应的 bit 置1，同时对于在被选中的叶子节点更高位上的叶子节点，其对应 bit 也需要被置1，这就需要额外的信息来辨别哪些节点是处在选择路径的高处。</p>
<p>gnrc_arbiter 中使用 <code class="docutils literal notranslate"><span class="pre">gnt_nodes</span></code> 来记录选择路径，使用 <code class="docutils literal notranslate"><span class="pre">rr_nodes</span></code> 来标记那些处于选择路径高位上的节点，判断逻辑如下。</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// start by root node</span>
<span class="k">assign</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gnt_i</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>

<span class="c1">// for level in tree</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">genvar</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="k">unsigned</span><span class="p">&#39;(</span><span class="n">level</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumLevels</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gen_levels</span>
<span class="w">    </span><span class="c1">// for node in level</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">genvar</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="n">level</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gen_level</span>

<span class="w">        </span><span class="c1">// index calcs</span>
<span class="w">        </span><span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="n">level</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="p">;</span><span class="c1">// current node</span>
<span class="w">        </span><span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="p">;</span><span class="c1">// odd node from upper Level connected to Idx0</span>
<span class="w">        </span><span class="k">localparam</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">Idx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="o">-</span><span class="mh">1</span><span class="o">+</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="o">+</span><span class="mh">1</span><span class="p">;</span><span class="c1">// even node from upper Level connected to Idx0</span>

<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">sel</span><span class="p">;</span>
<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">sel</span><span class="p">;</span>
<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx1</span><span class="p">]</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">];</span>
<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx2</span><span class="p">]</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="o">&amp;~</span><span class="n">sel</span><span class="p">;</span>

<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>最终 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 取决于最下层的 <code class="docutils literal notranslate"><span class="pre">gnt_nodes</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rr_nodes</span></code>，如果对应的 <code class="docutils literal notranslate"><span class="pre">rr_nodes</span></code> 为1，则说明子树所有节点都在被选中的节点的更高位，对应的 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> bit位可以 直接置1，否则根据选择路径来判断，若选择的是 odd node，则将 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 中下一级子树中的 odd node 和 even node 对应的bit都置1，若选择的是 even node，则只将 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 中 even node 对应的bit置1。</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// start by root node</span>
<span class="k">assign</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gnt_i</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>

<span class="c1">// for level in tree</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">genvar</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="k">unsigned</span><span class="p">&#39;(</span><span class="n">level</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumLevels</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gen_levels</span>
<span class="w">    </span><span class="c1">// for node in level</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">genvar</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">2</span><span class="o">**</span><span class="n">level</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gen_level</span>

<span class="w">        </span><span class="c1">// lowest level</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">unsigned</span><span class="p">&#39;(</span><span class="n">level</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NumLevels</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="k">assign</span><span class="w"> </span><span class="n">rr_d</span><span class="p">[</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="p">]</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="o">&amp;~</span><span class="n">sel</span><span class="p">;</span>
<span class="w">            </span><span class="k">assign</span><span class="w"> </span><span class="n">rr_d</span><span class="p">[</span><span class="n">l</span><span class="o">*</span><span class="mh">2</span><span class="o">+</span><span class="mh">1</span><span class="p">]</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">rr_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">gnt_nodes</span><span class="p">[</span><span class="n">Idx0</span><span class="p">];</span>
<span class="w">        </span><span class="k">end</span>

<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>还是来看之前的例子，产生 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 的信号路线如下图所示。</p>
<img alt="../../_images/arbiter_gen_rrd.svg" src="../../_images/arbiter_gen_rrd.svg" /></section>
<section id="generate-gnt-o">
<h2>Generate “gnt_o”<a class="headerlink" href="#generate-gnt-o" title="此标题的永久链接"></a></h2>
<p>产生 <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> 的逻辑就是上面的 <code class="docutils literal notranslate"><span class="pre">gnt_nodes</span></code> 对应的绿色路径。</p>
</section>
<section id="from-highest-to-lowest">
<h2>From highest to lowest<a class="headerlink" href="#from-highest-to-lowest" title="此标题的永久链接"></a></h2>
<p>若需要把最高优先级的 requester 变为最低优先级，只需要将 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 向高位移动1bit。</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// rr_q shift using method 1</span>
<span class="c1">// -2 = {{N-1{1&#39;b1}},1&#39;b0}</span>
<span class="k">assign</span><span class="w"> </span><span class="n">rr_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rr_q</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="mh">2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="n">rr_q</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">],</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 的第3种更新方式中（对应 <code class="docutils literal notranslate"><span class="pre">DEPTH=</span> <span class="pre">2</span></code> ），需要将当前许可 <cite>requester</cite> 的下一个 <strong>有效的</strong> <cite>requester</cite> 设置为最高优先级，因此需要分别产生当前许可的 <cite>requester</cite> 作为 <code class="docutils literal notranslate"><span class="pre">gnt_o</span></code> 和下一个有效的 <cite>requester</cite> 作为 <code class="docutils literal notranslate"><span class="pre">rr_d</span></code> 。 此时需要分别用两个树型结构，一个正常使用 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 作为 mask 寻找当前许可的 <cite>requester</cite> ，另一个使用左移一位的 <code class="docutils literal notranslate"><span class="pre">rr_q</span></code> 作为 mask 寻找下一个有效的 <cite>requester</cite> 。</p>
</section>
<section id="timing-area">
<h2>Timing &amp; Area<a class="headerlink" href="#timing-area" title="此标题的永久链接"></a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">N=16</span></code> ， <code class="docutils literal notranslate"><span class="pre">DW=1</span></code> ， <code class="docutils literal notranslate"><span class="pre">DEPTH=2</span></code> （对应rr_arb_tree <code class="docutils literal notranslate"><span class="pre">FairArb=1</span></code>  ）的配置下，使用vivado综合，芯片xc7vxt485ffg1157-1，100MHz时钟约束，所有输入设置2ns input delay，输出为0ns output delay</p>
<ul>
<li><p>Timing的结果（前面的是 rr_arb_tree ，后面的是 gnrc_arbiter）</p>
<a class="reference internal image-reference" href="../../_images/arbiter_timing0.png"><img alt="../../_images/arbiter_timing0.png" src="../../_images/arbiter_timing0.png" style="width: 794.5px; height: 193.89999999999998px;" /></a>
<a class="reference internal image-reference" href="../../_images/arbiter_timing1.png"><img alt="../../_images/arbiter_timing1.png" src="../../_images/arbiter_timing1.png" style="width: 802.9px; height: 193.89999999999998px;" /></a>
</li>
<li><p>area的结果（前面的是 rr_arb_tree ，后面的是 gnrc_arbiter）</p>
<a class="reference internal image-reference" href="../../_images/arbiter_area0.png"><img alt="../../_images/arbiter_area0.png" src="../../_images/arbiter_area0.png" style="width: 273.7px; height: 200.89999999999998px;" /></a>
<a class="reference internal image-reference" href="../../_images/arbiter_area1.png"><img alt="../../_images/arbiter_area1.png" src="../../_images/arbiter_area1.png" style="width: 278.59999999999997px; height: 200.89999999999998px;" /></a>
</li>
</ul>
<p>可以看出 timing 和 LUT 使用量略胜一筹，但正如 rr_arb_tree 注释中所述：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/// * The trailing zero counter (`lzc`) has a loglog relation of input to output timing. This means
///   that in this module the input to register path scales with Log(Log(`NumIn`)).
/// * The `rr_arb_tree` data multiplexing scales with Log(`NumIn`). This means that the input to output
///   timing path of this module also scales scales with Log(`NumIn`).
/// This implies that in this module the input to output path is always longer than the input to
/// register path. As the output data usually also terminates in a register the parameter `FairArb`
</pre></div>
</div>
<p>最长的路径一般都在 input 到 output 之间的数据通路上，而在这一方面 gnrc_arbiter 和 rr_arb_tree区别不大。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="gnrc_spram.html" class="btn btn-neutral float-left" title="gnrc_spram" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2023, QyLey.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>